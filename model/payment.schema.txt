const mongoose = require('mongoose');
const getGrade = require('../config/gradeUtils');

const userSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    trim: true
  },
  lastName: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['super_admin', 'admin', 'teacher', 'student'],
    required: true,
    default: 'student'
  },
  assignedClasses: [{
    class: {
      type: String,
      required: true
    },
    section: {
      type: String,
      required: true
    }
  }],
  adminCode: {
    type: String,
    unique: true,
    sparse: true
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null
  },
  refreshTokens: [{
    token: {
      type: String,
      required: true
    },
    createdAt: {
      type: Date,
      default: Date.now,
      expires: 7 * 24 * 60 * 60
    }
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
});

const studentSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  userName: {
    type: String,
    required: true,
    trim: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  roll: {
    type: Number,
    required: true
  },
  class: {
    type: String,
    required: true
  },
  section: {
    type: String,
    required: true
  },
  paymentAmount: {
    type: Number,
    default: 0,
    min: 0
  },
  hasPaid: {
    type: Boolean,
    default: false
  },
  paymentDetails: [{
    initialAmount: {
      type: Number,
      required: true,
      min: 0
    },
    increasedAmount: {
      type: Number,
      required: true,
      min: 0
    },
    dueDate: {
      type: Date,
      required: true
    },
    isPaid: {
      type: Boolean,
      default: false
    },
    createdAt: {
      type: Date,
      default: Date.now
    }
  }],
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  refreshTokens: [{
    token: {
      type: String,
      required: true
    },
    createdAt: {
      type: Date,
      default: Date.now,
      expires: 7 * 24 * 60 * 60
    }
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Pre-save middleware to update paymentAmount and hasPaid based on paymentDetails
studentSchema.pre('save', function (next) {
  try {
    if (this.paymentDetails && this.paymentDetails.length > 0) {
      const latestPayment = this.paymentDetails[this.paymentDetails.length - 1];
      const currentDate = new Date();
      this.hasPaid = latestPayment.isPaid;
      if (latestPayment.isPaid) {
        this.paymentAmount = 0;
      } else if (currentDate > latestPayment.dueDate) {
        this.paymentAmount = latestPayment.increasedAmount;
      } else {
        this.paymentAmount = latestPayment.initialAmount;
      }
    } else {
      this.paymentAmount = 0;
      this.hasPaid = false;
    }
    next();
  } catch (err) {
    console.error('Pre-save payment error:', err.message);
    next(err);
  }
});

const resultSchema = new mongoose.Schema({
  student: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Student',
    required: true
  },
  class: {
    type: String,
    required: true
  },
  semester: {
    type: String,
    enum: ['1st', '2nd', '3rd'],
    required: true
  },
  marks: [
    {
      subject: {
        type: String,
        required: true
      },
      cq: {
        type: Number,
        required: true,
        min: 0,
        max: 100
      },
      mcq: {
        type: Number,
        required: true,
        min: 0,
        max: 100
      },
      total: {
        type: Number,
        required: true,
        min: 0,
        max: 100
      },
      grade: {
        type: String
      },
      gpa: {
        type: Number
      }
    }
  ],
  totalMarks: {
    type: Number,
    default: 0
  },
  averageGPA: {
    type: Number,
    default: 0
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Pre-save middleware to calculate total, grades, totalMarks, and averageGPA
resultSchema.pre('save', function (next) {
  try {
    if (!this.marks || this.marks.length === 0) {
      console.error('Pre-save error: Marks array is empty');
      return next(new Error('Marks array cannot be empty'));
    }

    let total = 0;
    let gpaSum = 0;

    this.marks = this.marks.map((m) => {
      if (typeof m.cq !== 'number' || isNaN(m.cq) || typeof m.mcq !== 'number' || isNaN(m.mcq)) {
        console.error(`Pre-save error: Invalid CQ/MCQ for subject ${m.subject}: CQ=${m.cq}, MCQ=${m.mcq}`);
        return next(new Error(`Invalid CQ or MCQ score for subject ${m.subject}`));
      }
      const totalScore = m.cq + m.mcq;
      if (totalScore > 100) {
        console.error(`Pre-save error: Total score exceeds 100 for subject ${m.subject}: ${totalScore}`);
        return next(new Error(`Total score for ${m.subject} exceeds 100`));
      }
      const { grade, gpa } = getGrade(totalScore);
      total += totalScore;
      gpaSum += gpa;
      return { ...m, total: totalScore, grade, gpa };
    });

    this.totalMarks = total;
    this.averageGPA = this.marks.length > 0 ? (gpaSum / this.marks.length).toFixed(2) : 0;

    console.log('Pre-save calculated:', { totalMarks: this.totalMarks, averageGPA: this.averageGPA });
    next();
  } catch (err) {
    console.error('Pre-save error:', err.message);
    next(err);
  }
});

const User = mongoose.model('User', userSchema);
const Student = mongoose.model('Student', studentSchema);
const Result = mongoose.model('Result', resultSchema);

module.exports = { User, Student, Result };